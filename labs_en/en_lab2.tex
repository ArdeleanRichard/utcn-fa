\documentclass[../en-fa-lab.tex]{subfiles}
\usepackage{soul}

\usepackage{hyperref}
\hypersetup{
    pdftitle={(EN) L2 - Build heap and Heapsort},   % The title shown in the browser tab
    pdfauthor={},         % Your name or organization
    pdfsubject={},   % A brief description
    pdfkeywords={}
}

\begin{document}

\section{\texorpdfstring{\textbf{Assignment No. 2: Analysis \& Comparison of Bottom-up and
Top-down Build Heap Approaches}}{Assignment No. 2: Analysis \& Comparison of Bottom-up and
Top-down Build Heap Approaches}}\label{intro-session}

\textbf{Allocated time:} 2 hours

\subsection{Implementation}\label{implementation}

You are required to implement \textbf{correctly} and
\textbf{efficiently} two methods for building a heap, namely the
\emph{bottom-up} and the \emph{top-down} strategies. Moreover, you are
required to implement the \emph{heapsort} algorithm.

You may find any necessary information and pseudo-code in
your course notes, or in the book\citep{cormen}:

\begin{itemize}
\item
  \emph{Bottom-up}: section 6.3 (Building a heap)
\item
  \emph{Heapsort}: chapter 6.4 (The heapsort algorithm)
\item
  \emph{Top-down}: section 6.5 (Priority queues) and
  problem 6-1 (Building a heap using insertion)
\end{itemize}

\subsection{Minimal requirements for
grading}\label{minimal-requirements-for-grading}

\begin{itemize}
\item
  Interpret the chart and write your observations in the header (block
  comments) section at the beginning of your \emph{main.cpp} file.
\end{itemize}

\begin{itemize}
\item
  Prepare a demo for each algorithm implemented.
\item
  We do not accept assignments without code indentation and with code
  not organized in functions (for example where the entire code is in
  the main function).
\item
  \emph{\textbf{The points from the requirements correspond to a correct
  and complete solution, quality of interpretation from the block
  comment and the correct answer to the questions from the teacher.}}
\end{itemize}

\subsection{Requirements}\label{requirements}

\subsubsection{\texorpdfstring{Comparative analysis of \emph{one} of the
sorting algorithms from L1 (you choose) in \emph{iterative} vs
\emph{recursive} version. The analysis should be performed based on the
\emph{\ul{number of operations} and the \ul{runtime}}
(2p)}{Comparative analysis of one of the sorting algorithms from L1 (you choose) in iterative vs recursive version. The analysis should be performed based on the number of operations and the runtime (2p)}}\label{comparative-analysis-of-one-of-the-sorting-algorithms-from-l1-you-choose-in-iterative-vs-recursive-version.-the-analysis-should-be-performed-based-on-the-number-of-operations-and-the-runtime-2p}

For the comparative analysis of the iterative vs recursive version pick
one of the 3 algorithms from Assignment 1 (bubble sort, insertion or
selection). Use the iterative version that you already implemented
(corrected, if needed, based on the feedback received from the teacher)
and implement the same algorithm in the recursive version.

You must measure the total effort and the running time of the two
versions (iterative and recursive) =\textgreater{} two charts, each of
them comparing the two versions of the algorithm.

For measuring the runtime, you can use Profiler similar to the example
below. 
\\

\emph{profiler.startTimer("your\_function", current\_size);}

\emph{for(int test=0; test\textless nr\_tests; ++test) \{}

\quad\emph{your\_function(array, current\_size);}

\emph{\}}

\emph{profiler.stopTimer("your\_function", current\_size);}
\\

The number of tests (\emph{nr\_tests} from the above example) has to be
chosen based on your processor and the compile mode used. We suggest
bigger values such as 100 or 1000.

\subsubsection{Implement bottom­up build heap procedure
(2p)}\label{implement-bottomup-build-heap-procedure-2p}

You will have to prove your algorithm(s) work on a small-sized input.

\subsubsection{Implement top­down build heap procedure
(2p)}\label{implement-topdown-build-heap-procedure-2p}

You will have to prove your algorithm(s) work on a small-sized input.

\subsubsection{Comparative analysis of the two build heap methods in the
average case
(2p)}\label{comparative-analysis-of-the-two-build-heap-methods-in-the-average-case-2p}

\textbf{!} Before you start to work on the algorithms evaluation code,
make sure you have a \emph{correct} algorithm!

You are required to compare the two build heap procedures in the
\textbf{average} case. Remember that for the \textbf{average} case you
have to repeat the measurements m times (m=5) and report their average;
also, for the \textbf{average} case, make sure you always use the
\textbf{same} input sequence for the two methods -- to make the
comparison fair.

This is how the analysis should be performed:

- vary the dimension of the input array (\emph{n}) between
{[}100\ldots10000{]}, with an increment of maximum 500 (we suggest 100).

- for each dimension (\emph{n}), generate the appropriate input sequence
for the method; run the method, counting the operations (assignments and
comparisons, may be counted together for this assignment).

\begin{quote}
\textbf{!} Only the assignments and comparisons performed on the input
structure and its corresponding auxiliary variables matter.

Generate a chart which compares the two methods under the total number
of operations, in the \textbf{average} case. If one of the curves cannot
be visualized correctly because the other has a larger growth rate,
place that curve on a separate chart as well. Name your chart and the
curves on it appropriately.
\end{quote}

\subsubsection{Comparative analysis of the two build heap methods in the
worst case
(1p)}\label{comparative-analysis-of-the-two-build-heap-methods-in-the-worst-case-1p}

\subsubsection{Implement and exemplify correctness of heapsort
(1p)}\label{implement-and-exemplify-correctness-of-heapsort-1p}

You will have to prove your algorithm(s) work on a small-sized input.

\end{document}