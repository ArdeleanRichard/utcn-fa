\documentclass[../en-fa-lab.tex]{subfiles}


\usepackage{hyperref}
\hypersetup{
    pdftitle={(EN) L3 - Heapsort vs Quicksort},   % The title shown in the browser tab
    pdfauthor={},         % Your name or organization
    pdfsubject={},   % A brief description
    pdfkeywords={}
}

\begin{document}

\section{\texorpdfstring{\textbf{Assignment No. 3: Analysis \& Comparison of Advanced Sorting
Methods -- Heapsort and Quicksort / QuickSelect}}{Assignment No. 3: Analysis \& Comparison of Advanced Sorting
Methods -- Heapsort and Quicksort / QuickSelect}}\label{assign3}

\textbf{Allocated time:} 2 hours

\subsection{Implementation}\label{implementation}

You are required to implement \textbf{correctly} and
\textbf{efficiently} \emph{Quicksort, Hybrid Quicksort} and
\emph{Quick-Select (Randomized-Select)}. You are also required to
analyze comparatively of the complexity of \emph{Heapsort} (implemented
in Assignment No. 2) and \emph{Quicksort}.

You may find any necessary information and pseudo-code in
your course notes, or in the book\citep{cormen}:

\begin{itemize}
\item
  \emph{Heapsort}: chapter 6 (Heapsort)
\item
  \emph{Quicksort}: chapter 7 (Quicksort)
\item
  \emph{Hybridization for quicksort using iterative
  insertion sort -} in quicksort, for array sizes \textless{} threshold,
  insertion sort should be used (use insertion sort from Assignment No.
  1)
\item
  \emph{Randomized-Select}: chapter 9
\end{itemize}

\subsection{Minimal requirements for
grading}\label{minimal-requirements-for-grading}

\begin{itemize}
\item
  Interpret the chart and write your observations in the header (block
  comments) section at the beginning of your \emph{main.cpp} file.
\end{itemize}

\begin{itemize}
\item
  Prepare a demo for each algorithm implemented.
\item
  We do not accept assignments without code indentation and with code
  not organized in functions (for example where the entire code is in
  the main function).
\item
  \emph{\textbf{The points from the requirements correspond to a correct
  and complete solution, quality of interpretation from the block
  comment and the correct answer to the questions from the teacher.}}
\end{itemize}

\subsection{Requirements}\label{requirements}

\subsubsection{QuickSort: implementation
(2p)}\label{quicksort-implementation-2p}

You will have to prove your algorithm(s) work on a small-sized input.

\subsubsection{QuickSort: average, best and worst case analysis
(3p)}\label{quicksort-average-best-and-worst-case-analysis-3p}

\textbf{!} Before you start to work on the algorithms evaluation code,
make sure you have a \textbf{correct algorithm}!

This is how the analysis should be performed:

- vary the dimension of the input array (\emph{n}) between
{[}100\ldots10000{]}, with an increment of maximum 500 (we suggest 100).

- for each dimension, generate the appropriate input sequence for the
method; run the method, counting the operations (assignments and
comparisons, may be counted together).

\begin{quote}
\textbf{!} Only the assignments and comparisons performed on the input
structure and its corresponding auxiliary variables matter.
\end{quote}

\subsubsection{Quicksort and Heapsort: comparative analysis of average case
(2p)}\label{quicksort-and-heapsort-comparative-analysis-of-average-case-2p}

You are required to compare the two sorting procedures in the
\textbf{average} case. Remember that for the \textbf{average} case you
have to repeat the measurements \emph{m} times (m=5) and report their
average; also for the \textbf{average} case, make sure you always use
the \textbf{same} input sequence for the two methods -- to make the
comparison fair.

Generate a chart which compares the two methods under the total number
of operations, in the \textbf{average} case.

If one of the curves cannot be visualized correctly because the other
has a larger growth rate, place that curve on a separate chart as well.
Name the chart and curves appropriately.

\subsubsection{Implementation of quicksort hybridization
(1p)}\label{implementation-of-quicksort-hybridization-1p}

You will have to prove your algorithm(s) work on a small-sized input.

\subsubsection{Determination of an optimal threshold used in hybridization
+ proof (graphics/ measurements)
(1p)}\label{determination-of-an-optimal-threshold-used-in-hybridization-proof-graphics-measurements-1p}

You should vary the threshold value of quicksort hibridization for which
insertion sort is applied.

Compare the results from the performance (number of operations and
execution time) perspective for determination of the optimum threshold.
You can use 10.000 as the fixed size of the vector that is being sorted
and vary the threshold between {[}5,50{]} with an increment of 1 to 5.

The number of tests (nr\_tests from the example) has to be chosen based
on your processor and the compile mode used. We suggest bigger values
such as 100 or 1000.

\subsubsection{\texorpdfstring{Comparative analysis (between
\emph{quicksort and quicksort hibridization}) from the operations and
runtime perspective
(1p)}{Comparative analysis (between quicksort and quicksort hibridization) from the operations and runtime perspective (1p)}}\label{comparative-analysis-between-quicksort-and-quicksort-hibridization-from-the-operations-and-runtime-perspective-1p}

\textbf{!} Before you start to work on the algorithms evaluation code,
make sure you have a correct algorithm!

For quicksort hybridization, you have to use the iterative insertion
sort from the first assignment if the size of the vector is small (we
suggest using insertion sort if the vector has less than 30 elements).
Compare \emph{runtime and the number of operations} (assignments +
comparisons) for quicksort implemented in the third assignment with the
hybrid one.

For measuring the runtime you can use Profiler similar to the example
below.
\\

\emph{profiler.startTimer("your\_function", current\_size);}

\emph{for(int test=0; test\textless nr\_tests; ++test) \{}

\quad\emph{your\_function(array, current\_size);}

\emph{\}}

\emph{profiler.stopTimer("your\_function", current\_size);}
\\

When you are measuring the execution time make sure all the processes
that are not critical are stopped.

\subsubsection{Bonus: QuickSelect - Randomized-Select
(0.5p)}\label{bonus-quickselect---randomized-select-0.5p}

You will have to prove your algorithm(s) work on a small-sized input.

For QuickSelect (Randomized-Select) no explicit complexity analysis
needs to be performed, only the correctness needs to be demonstrated on
sample inputs.

\end{document}