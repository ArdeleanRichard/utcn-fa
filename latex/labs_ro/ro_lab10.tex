\documentclass[../ro-fa-lab.tex]{subfiles}
\usepackage{hyperref}
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{amsmath}

\hypersetup{
    pdftitle={(RO) L10 - DFS},   % The title shown in the browser tab
    pdfauthor={},         % Your name or organization
    pdfsubject={},   % A brief description
    pdfkeywords={}
}

\begin{document}


\section{\texorpdfstring{\textbf{Tema Nr. 10: Căutare în adâncime (DFS)}}{Tema Nr. 10: Căutare în adâncime (DFS)}}\label{assign9}

\textbf{Tema Nr. 10: Căutare în adâncime (DFS)}

\textbf{Timp Alocat}: 2 ore

\subsection{Implementare}\label{implementare}

Se cere implementarea corectă și eficientă a algoritmului de căutare în
adâncime (Depth-First Search - DFS) (\emph{Capitolul
22.3 din \cite{cormen}}). Pentru reprezentarea grafurilor, va trebui să
folosești liste de adiacență. De asemenea, va trebui să:

\begin{itemize}
\item
  Implementați sortarea topologică (\emph{Capitolul
  22.4} din \emph{\cite{cormen}})
\item
  Implementați algoritmul Tarjan pentru componente tare conexe
\end{itemize}





\subsection{Cerințe minimale pentru notare}\label{cerinux21be-minimale-pentru-notare}

Lipsa oricărei cerințe minimale (chiar și parțială) poate rezulta într-o notă mai mică prin penalizări sau refuzul de a prelua tema, rezultând în nota 0.

\begin{itemize}
\item
  \emph{Demo}: Pregătiți un exemplu pentru exemplificarea corectitudinii fiecărui
  algoritm implementat. Corectitudinea fiecărui algoritm se demonstrează printr-un exemplu simplu (maxim 10 valori).
\item
    Graficele create trebuie să fie ușor de evaluat, adică grupate și adunate prin funcțiile Profiler după cerințele temei. Tema nu va fi evaluată dacă conține o multitudine de grafice negrupate. De exemplu, analiza comparativă implică gruparea într-un singur grafic a algoritmilor comparați.
\item
  Interpretați graficul/graficele și notați observațiile personale în antetul
  fișierului \emph{main.cpp}, într-un comentariu bloc informativ.
\item
  Nu preluăm teme care nu sunt indentate și care nu sunt organizate în
  funcții (de exemplu, nu prelăum teme unde tot codul este pus în main).
\item
  \emph{Punctajele din barem sunt corespondente unei rezolvări corecte și
  complete a cerinței, calitatea interpretărilor din comentariul bloc și
  \textbf{răspunsul corect dat de dumeavostră la întrebările puse de către profesor.}}
\end{itemize}









\subsection{Cerințe}\label{cerinux21be}

\subsubsection{DFS (5p)}\label{dfs-5p}

\emph{Demo}: Demonstrați corectitudinea algoritmului pe un graf de dimensiune mică:

\begin{itemize}
\item
  afișați graful inițial (liste de adiacență)
\item
  afișați arborele rezultat în urma DFS
\end{itemize}

\subsubsection{Sortare topologică (1p)}\label{sortare-topologicux103-1p}

\emph{Demo}: Demonstrați corectitudinea algoritmului pe un graf de dimensiune mică:

\begin{itemize}
\item
  afișați graful inițial (liste de adiacență)
\item
  afișați listă de noduri sortate topologic (dacă are / dacă nu are de
  ce nu are?)
\end{itemize}

\subsubsection{Tarjan (2p)}\label{tarjan-2p}

\emph{Demo}: Demonstrați corectitudinea algoritmului pe un graf de dimensiune mică:

\begin{itemize}
\item
  afișați graful inițial (liste de adiacență)
\item
  afișați componentele puternic conexe ale grafului
\end{itemize}

Prezentăm algoritmul lui Tarjan pentru identificarea componentelor tare conexe (SCC) într-un graf orientat.
Pentru context și mai multe detalii, consultați articolul de pe Wikipedia:
\href{https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm}{Algoritmul lui Tarjan pentru componentele tare conexe}.
Pseudocodul poate fi găsit și \hyperref[alg:tarjan]{aici}.





\subsubsection{Analiza performanței pentru DFS
(2p)}\label{analiza-performanux21bei-pentru-dfs-2p}

Cum timpul de execuție al algoritmului DFS variază în funcție de numărul
de vârfuri (\textbar V\textbar) și de numărul de muchii
(\textbar E\textbar) aveți de făcut următoarele analize:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Fixați \textbar V\textbar=100 și variați \textbar E\textbar{} între
  1000 și 4500 cu un pas de 100. Generați pentru fiecare caz un graf
  aleator și asigurați-vă că nu generați aceeași muchie de 2 ori.
  Execută DFS pentru fiecare graf generat și numără operațiile
  efectuate. Apoi construiește graficul cu variația numărului de
  operații în funcție de \textbar E\textbar;
\item
  Fixați \textbar E\textbar=4500 și variați \textbar V\textbar{} între
  100 și 200 cu un pas de 10. Repetă procedura de mai sus și
  construiește graficul cu variația numărului de operații în funcție de
  \textbar V\textbar.
\end{enumerate}





\begin{algorithm}
\caption{Tarjan's strongly connected components}
\label{alg:tarjan}
\begin{algorithmic}[1]

\Procedure{tarjan}{$G=(V,E)$}
    \State \textbf{Input:} graph $G = (V, E)$
    \State \textbf{Output:} set of strongly connected components (sets of vertices)
    \State $index \gets 0$
    \State $S \gets$ empty stack
    \ForAll{$v \in V$}
        \If{$v.index$ is undefined}
            \State \Call{strongconnect}{$v$}
        \EndIf
    \EndFor
\EndProcedure

\Statex % <-- empty line between the two functions

\Function{strongconnect}{$v$}
    \State {\small\texttt{// Set the depth index for v to the smallest unused index}}
    \State $v.\text{index} \gets index$
    \State $v.\text{lowlink} \gets index$
    \State $index \gets index + 1$
    \State $S.push(v)$
    \State $v.onStack \gets \text{true}$

    \State {\small\texttt{// Consider successors of v}}
    \ForAll{$(v, w) \in E$}
        \If{$w.index$ is undefined}
            \State {\small\texttt{// Successor w has not yet been visited; recurse on it}}
            \State \Call{strongconnect}{$w$}
            \State $v.\text{lowlink} \gets \min(v.\text{lowlink}, w.\text{lowlink})$
        \ElsIf{$w.onStack$}
            \State {\small\texttt{// Successor w is in stack S and hence in the current SCC}}
            \State {\small\texttt{// If w is not on stack, then (v, w) is an edge pointing to an SCC already}}
            \State {\small\texttt{// found and must be ignored}}
            \State {\small\texttt{// See below regarding the next line}}
            \State $v.\text{lowlink} \gets \min(v.\text{lowlink}, w.\text{index})$
        \EndIf
    \EndFor

    \State {\small\texttt{// If v is a root node, pop the stack and generate an SCC}}
    \If{$v.\text{lowlink} = v.\text{index}$}
        \State start a new strongly connected component
        \Repeat
            \State $w \gets S.pop()$
            \State $w.onStack \gets \text{false}$
            \State add $w$ to current strongly connected component
        \Until{$w = v$}
        \State \textbf{output} the current strongly connected component
    \EndIf
\EndFunction

\end{algorithmic}
\end{algorithm}


\printbibliography

\end{document}