\documentclass[../en-fa-lab.tex]{subfiles}

\usepackage{hyperref}

\hypersetup{
    pdftitle={(EN) L7 - Dynamic order statistics},   % The title shown in the browser tab
    pdfauthor={},         % Your name or organization
    pdfsubject={},   % A brief description
    pdfkeywords={}
}

\begin{document}

\section{\texorpdfstring{\textbf{Assignment No. 7: Dynamic Order Statistics}}{Assignment No. 7: Dynamic Order Statistics}}\label{assign7}

\textbf{Allocated time:} 2 hours

\subsection{Implementation}\label{implementation}

You are required to implement \textbf{correctly} and
\textbf{efficiently} the management operations of an \textbf{order
statistics tree} (\emph{chapter 14.1 from \cite{cormen}}).

You have to use a balanced, augmented Binary Search Tree. Each node in
the tree holds, besides the necessary information, also the \emph{size}
field (i.e. the size of the sub-tree rooted at the node).

The management operations of an \textbf{order statistics tree} are:

\begin{itemize}
\item
  BUILD\_TREE(n)

  \begin{itemize}
  \item
    \emph{builds} a \textbf{balanced} BST containing the keys 1,2,...n
    (\emph{hint:} use a divide and conquer approach)
  \item
    make sure you initialize the size field in each tree node
  \end{itemize}
\item
  OS-SELECT(tree, i)

  \begin{itemize}
  \item
    selects the element with the \emph{i}-th smallest key
  \item
    the pseudo-code is available in \emph{chapter 14.1 from the
    book\cite{cormen}}
  \end{itemize}
\item
  OS-DELETE(tree, i)

  \begin{itemize}
  \item
    you may use the deletion from a BST, without increasing the height
    of the tree (why don't you need to rebalance the tree?)
  \item
    keep the size information consistent after subsequent deletes
  \item
    there are several alternatives to update the size field without
    increasing the complexity of the algorithm (it is up to you to
    figure this out).
  \end{itemize}
\end{itemize}


Does OS-SELECT resemble anything you studied this semester?

% \begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}


\subsection{Minimal requirements for grading}\label{minimal-requirements-for-grading}

The lack of any of the minimum requirements (even partially) may result in a lower grade through penalties or refusal to accept the assignment resulting in a grade of 0.

\begin{itemize}
\item
  \emph{Demo}: Prepare a demonstration of correctness for each algorithm implemented. The correctness of each algorithm is demonstrated through a simple example (maximum 10 values).
\item
  The charts created must be easy to evaluate as in grouped and added through the Profiler functions as specified by the assignment requirements. The assignment will not be evaluated if it contains a plethora of ungrouped charts. For example, the comparative analysis implies the grouping of the compared algorithms.
\item
  Interpret the chart and write your observations in the header (block
  comments) section at the beginning of your \emph{main.cpp} file.
\item
  We do not accept assignments without code indentation and with code
  not organized in functions (for example where the entire code is in
  the main function).
\item
  \emph{The points from the requirements correspond to a correct
  and complete solution, quality of interpretation from the block
  comment and \textbf{the correct answer to the questions from the teacher.}}
\end{itemize}






\subsection{Requirements}\label{requirements}

\subsubsection{BUILD\_TREE: correct and efficient implementation
(5p)}\label{build_tree-correct-and-efficient-implementation-5p}

\emph{Demo}: You will have to prove your algorithm(s) work on a small-sized input
(11)

\begin{itemize}
\item
  pretty-print the initially built tree
\end{itemize}

\subsubsection{OS\_SELECT: correct and efficient implementation
(1p)}\label{os_select-correct-and-efficient-implementation-1p}

\emph{Demo}: You will have to prove your algorithm(s) work on a small-sized input
(11)

\begin{itemize}
\item
  execute OS-SELECT for a few elements (at least 3) by a randomly
  selected index
\end{itemize}

\subsubsection{OS\_DELETE: correct and efficient implementation
(2p)}\label{os_delete-correct-and-efficient-implementation-2p}

\emph{Demo}: You will have to prove your algorithm(s) work on a small-sized input
(11)

\begin{itemize}
\item
  execute OS-SELECT followed by OS-DELETE for a few elements (at least
  3) by a randomly selected index \emph{and pretty-print the tree after
  each execution}.
\end{itemize}

\subsubsection{Management operations evaluation - BUILD, SELECT, DELETE
(2p)}\label{management-operations-evaluation---build-select-delete-2p}

Once you are sure your program works correctly:

\begin{itemize}
\item
  vary \emph{n} from 100 to 10000 with a step of 100;
\item
  for each n (don't forget to repeat 5 times),

  \begin{itemize}
  \item
    BUILD a tree with elements from \emph{1 to n}
  \item
    perform \emph{n} sequences of OS-SELECT and OS-DELETE operations
    using a randomly selected index based on the remaining number of
    elements in the BST,
  \item
    Evaluate the number of operations needed for each management
    operation (BUILD, SELECT, DELETE \emph{-- resulting in a plot with 3
    series}). Evaluate the computational effort as the sum of the
    comparisons and assignments performed by each individual management
    operation ofr each value of \emph{n}.
  \end{itemize}
\end{itemize}

\subsubsection{Bonus: Implementation using AVL / Red black tree
(1p)}\label{bonus-implementation-using-avl-red-black-tree-1p}

\emph{Demo}: You will have to prove your algorithm(s) work on a small-sized input
(11) 

\printbibliography

\end{document}