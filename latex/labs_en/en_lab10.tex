\documentclass[../en-fa-lab.tex]{subfiles}

\usepackage{hyperref}
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{amsmath}

\hypersetup{
    pdftitle={(EN) L10 - DFS},   % The title shown in the browser tab
    pdfauthor={},         % Your name or organization
    pdfsubject={},   % A brief description
    pdfkeywords={}
}


\begin{document}

\section{\texorpdfstring{\textbf{Assignment 10: Depth-first search (DFS)}}{Assignment 10: Depth-first search (DFS)}}\label{assign10}
\textbf{}

\textbf{Allocated time: 2 hours}

\subsection{Implementation}\label{implementation}

You are required to correctly and efficiently implement the depth first
search algorithm (DFS) (\emph{Chapter 22.3 from \cite{cormen}}). For
graph representation, you should use adjacency lists. You also have to:

\begin{itemize}
\item
  Implement topological sorting (\emph{Chapter 22.4 from \cite{cormen}})
\item
  Implement the Tarjan algorithm for detecting strongly connected
  components
\end{itemize}




\subsection{Minimal requirements for grading}\label{minimal-requirements-for-grading}

The lack of any of the minimum requirements (even partially) may result in a lower grade through penalties or refusal to accept the assignment resulting in a grade of 0.

\begin{itemize}
\item
  \emph{Demo}: Prepare a demonstration of correctness for each algorithm implemented. The correctness of each algorithm is demonstrated through a simple example (maximum 10 values).
\item
  The charts created must be easy to evaluate as in grouped and added through the Profiler functions as specified by the assignment requirements. The assignment will not be evaluated if it contains a plethora of ungrouped charts. For example, the comparative analysis implies the grouping of the compared algorithms.
\item
  Interpret the chart and write your observations in the header (block
  comments) section at the beginning of your \emph{main.cpp} file.
\item
  We do not accept assignments without code indentation and with code
  not organized in functions (for example where the entire code is in
  the main function).
\item
  \emph{The points from the requirements correspond to a correct
  and complete solution, quality of interpretation from the block
  comment and \textbf{the correct answer to the questions from the teacher.}}
\end{itemize}





\subsection{Requirements}\label{requirements}

\subsubsection{DFS (5p)}\label{dfs-5p}

\emph{Demo}: Exemplify the correctness of your algorithm/implementation by running it
on a smaller graph:

\begin{itemize}
\item
  print the initial graph (the adjacency lists)
\item
  print the tree resulted from DFS
\end{itemize}

\subsubsection{Topological sort (1p)}\label{topological-sort-1p}

\emph{Demo}: Exemplify the correctness of your algorithm/implementation by running it
on a smaller graph:

\begin{itemize}
\item
  print the initial graph (the adjacency lists)
\item
  print a list of nodes sorted topologically (should this list be
  nonempty/if it is why so?)
\end{itemize}

\subsubsection{Tarjan (2p)}\label{tarjan-2p}

\emph{Demo}: Exemplify the correctness of your algorithm/implementation by running it
on a smaller graph:

\begin{itemize}
\item
  print the initial graph (the adjacency lists)
\item
  print all strongly connected components of the graph
\end{itemize}

We present Tarjan's algorithm for finding strongly connected components (SCCs) in a directed graph.
For background and more details see the Wikipedia entry:
\href{https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm}{Tarjan's strongly connected components algorithm}.
The pseudocode can also be found \hyperref[alg:tarjan]{here}.

\subsubsection{Analysis of the DFS performance
(2p)}\label{analysis-of-the-dfs-performance-2p}

Since, for a graph, both \textbar V\textbar{} and \textbar E\textbar{}
may vary, and the running time of DFS depends on both, we will make each
analysis in turn:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Set \textbar V\textbar{} = 100 and vary \textbar E\textbar{} between
  1000 and 4500, using a 100 increment. Generate the input graphs
  randomly -- make sure you don't generate the same edge twice for the
  same graph. Run the DFS algorithm for each graph and count the number
of operations performed; generate the corresponding chart (i.e., the variation of the number of operations with \textbar E\textbar).
\item
  Set \textbar E\textbar{} = 4500 and vary \textbar V\textbar{} between
  100 and 200, using an increment equal to 10. Repeat the procedure
  above to generate the chart which gives the variation of the number of
  operations with \textbar V\textbar.
\end{enumerate}



\begin{algorithm}
\caption{Tarjan's strongly connected components}
\label{alg:tarjan}
\begin{algorithmic}[1]

\Procedure{tarjan}{$G=(V,E)$}
    \State \textbf{Input:} graph $G = (V, E)$
    \State \textbf{Output:} set of strongly connected components (sets of vertices)
    \State $index \gets 0$
    \State $S \gets$ empty stack
    \ForAll{$v \in V$}
        \If{$v.index$ is undefined}
            \State \Call{strongconnect}{$v$}
        \EndIf
    \EndFor
\EndProcedure

\Statex % <-- empty line between the two functions

\Function{strongconnect}{$v$}
    \State {\small\texttt{// Set the depth index for v to the smallest unused index}}
    \State $v.\text{index} \gets index$
    \State $v.\text{lowlink} \gets index$
    \State $index \gets index + 1$
    \State $S.push(v)$
    \State $v.onStack \gets \text{true}$

    \State {\small\texttt{// Consider successors of v}}
    \ForAll{$(v, w) \in E$}
        \If{$w.index$ is undefined}
            \State {\small\texttt{// Successor w has not yet been visited; recurse on it}}
            \State \Call{strongconnect}{$w$}
            \State $v.\text{lowlink} \gets \min(v.\text{lowlink}, w.\text{lowlink})$
        \ElsIf{$w.onStack$}
            \State {\small\texttt{// Successor w is in stack S and hence in the current SCC}}
            \State {\small\texttt{// If w is not on stack, then (v, w) is an edge pointing to an SCC already}}
            \State {\small\texttt{// found and must be ignored}}
            \State {\small\texttt{// See below regarding the next line}}
            \State $v.\text{lowlink} \gets \min(v.\text{lowlink}, w.\text{index})$
        \EndIf
    \EndFor

    \State {\small\texttt{// If v is a root node, pop the stack and generate an SCC}}
    \If{$v.\text{lowlink} = v.\text{index}$}
        \State start a new strongly connected component
        \Repeat
            \State $w \gets S.pop()$
            \State $w.onStack \gets \text{false}$
            \State add $w$ to current strongly connected component
        \Until{$w = v$}
        \State \textbf{output} the current strongly connected component
    \EndIf
\EndFunction

\end{algorithmic}
\end{algorithm}



\printbibliography

\end{document}